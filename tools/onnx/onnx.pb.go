// Code generated by protoc-gen-go. DO NOT EDIT.
// source: onnx.proto

/*
Package onnx is a generated protocol buffer package.

It is generated from these files:
	onnx.proto

It has these top-level messages:
	AttributeProto
	ValueInfoProto
	NodeProto
	ModelProto
	StringStringEntryProto
	GraphProto
	TensorProto
	TensorShapeProto
	TypeProto
	OperatorSetIdProto
*/
package onnx

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Versioning
//
// ONNX versioning is specified in docs/IR.md and elaborated on in docs/Versioning.md
//
// To be compatible with both proto2 and proto3, we will use a version number
// that is not defined by the default value but an explicit enum number.
type Version int32

const (
	// proto3 requires the first enum value to be zero.
	// We add this just to appease the compiler.
	Version__START_VERSION Version = 0
	// The version field is always serialized and we will use it to store the
	// version that the  graph is generated from. This helps us set up version
	// control.
	// For the IR, we are using simple numbers starting with with 0x00000001,
	// which was the version we published on Oct 10, 2017.
	Version_IR_VERSION_2017_10_10 Version = 1
	// IR_VERSION 2 published on Oct 30, 2017
	// - Added type discriminator to AttributeProto to support proto3 users
	Version_IR_VERSION_2017_10_30 Version = 2
	// IR VERSION 3 published on Nov 3, 2017
	// - For operator versioning:
	//    - Added new message OperatorSetIdProto
	//    - Added opset_import in ModelProto
	// - For vendor extensions, added domain in NodeProto
	Version_IR_VERSION Version = 3
)

var Version_name = map[int32]string{
	0: "_START_VERSION",
	1: "IR_VERSION_2017_10_10",
	2: "IR_VERSION_2017_10_30",
	3: "IR_VERSION",
}
var Version_value = map[string]int32{
	"_START_VERSION":        0,
	"IR_VERSION_2017_10_10": 1,
	"IR_VERSION_2017_10_30": 2,
	"IR_VERSION":            3,
}

func (x Version) Enum() *Version {
	p := new(Version)
	*p = x
	return p
}
func (x Version) String() string {
	return proto.EnumName(Version_name, int32(x))
}
func (x *Version) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Version_value, data, "Version")
	if err != nil {
		return err
	}
	*x = Version(value)
	return nil
}
func (Version) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Note: this enum is structurally identical to the OpSchema::AttrType
// enum defined in schema.h.  If you rev one, you likely need to rev the other.
type AttributeProto_AttributeType int32

const (
	AttributeProto_UNDEFINED AttributeProto_AttributeType = 0
	AttributeProto_FLOAT     AttributeProto_AttributeType = 1
	AttributeProto_INT       AttributeProto_AttributeType = 2
	AttributeProto_STRING    AttributeProto_AttributeType = 3
	AttributeProto_TENSOR    AttributeProto_AttributeType = 4
	AttributeProto_GRAPH     AttributeProto_AttributeType = 5
	AttributeProto_FLOATS    AttributeProto_AttributeType = 6
	AttributeProto_INTS      AttributeProto_AttributeType = 7
	AttributeProto_STRINGS   AttributeProto_AttributeType = 8
	AttributeProto_TENSORS   AttributeProto_AttributeType = 9
	AttributeProto_GRAPHS    AttributeProto_AttributeType = 10
)

var AttributeProto_AttributeType_name = map[int32]string{
	0:  "UNDEFINED",
	1:  "FLOAT",
	2:  "INT",
	3:  "STRING",
	4:  "TENSOR",
	5:  "GRAPH",
	6:  "FLOATS",
	7:  "INTS",
	8:  "STRINGS",
	9:  "TENSORS",
	10: "GRAPHS",
}
var AttributeProto_AttributeType_value = map[string]int32{
	"UNDEFINED": 0,
	"FLOAT":     1,
	"INT":       2,
	"STRING":    3,
	"TENSOR":    4,
	"GRAPH":     5,
	"FLOATS":    6,
	"INTS":      7,
	"STRINGS":   8,
	"TENSORS":   9,
	"GRAPHS":    10,
}

func (x AttributeProto_AttributeType) Enum() *AttributeProto_AttributeType {
	p := new(AttributeProto_AttributeType)
	*p = x
	return p
}
func (x AttributeProto_AttributeType) String() string {
	return proto.EnumName(AttributeProto_AttributeType_name, int32(x))
}
func (x *AttributeProto_AttributeType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(AttributeProto_AttributeType_value, data, "AttributeProto_AttributeType")
	if err != nil {
		return err
	}
	*x = AttributeProto_AttributeType(value)
	return nil
}
func (AttributeProto_AttributeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 0}
}

type TensorProto_DataType int32

const (
	TensorProto_UNDEFINED TensorProto_DataType = 0
	// Basic types.
	TensorProto_FLOAT  TensorProto_DataType = 1
	TensorProto_UINT8  TensorProto_DataType = 2
	TensorProto_INT8   TensorProto_DataType = 3
	TensorProto_UINT16 TensorProto_DataType = 4
	TensorProto_INT16  TensorProto_DataType = 5
	TensorProto_INT32  TensorProto_DataType = 6
	TensorProto_INT64  TensorProto_DataType = 7
	TensorProto_STRING TensorProto_DataType = 8
	TensorProto_BOOL   TensorProto_DataType = 9
	// Advanced types
	TensorProto_FLOAT16    TensorProto_DataType = 10
	TensorProto_DOUBLE     TensorProto_DataType = 11
	TensorProto_UINT32     TensorProto_DataType = 12
	TensorProto_UINT64     TensorProto_DataType = 13
	TensorProto_COMPLEX64  TensorProto_DataType = 14
	TensorProto_COMPLEX128 TensorProto_DataType = 15
)

var TensorProto_DataType_name = map[int32]string{
	0:  "UNDEFINED",
	1:  "FLOAT",
	2:  "UINT8",
	3:  "INT8",
	4:  "UINT16",
	5:  "INT16",
	6:  "INT32",
	7:  "INT64",
	8:  "STRING",
	9:  "BOOL",
	10: "FLOAT16",
	11: "DOUBLE",
	12: "UINT32",
	13: "UINT64",
	14: "COMPLEX64",
	15: "COMPLEX128",
}
var TensorProto_DataType_value = map[string]int32{
	"UNDEFINED":  0,
	"FLOAT":      1,
	"UINT8":      2,
	"INT8":       3,
	"UINT16":     4,
	"INT16":      5,
	"INT32":      6,
	"INT64":      7,
	"STRING":     8,
	"BOOL":       9,
	"FLOAT16":    10,
	"DOUBLE":     11,
	"UINT32":     12,
	"UINT64":     13,
	"COMPLEX64":  14,
	"COMPLEX128": 15,
}

func (x TensorProto_DataType) Enum() *TensorProto_DataType {
	p := new(TensorProto_DataType)
	*p = x
	return p
}
func (x TensorProto_DataType) String() string {
	return proto.EnumName(TensorProto_DataType_name, int32(x))
}
func (x *TensorProto_DataType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TensorProto_DataType_value, data, "TensorProto_DataType")
	if err != nil {
		return err
	}
	*x = TensorProto_DataType(value)
	return nil
}
func (TensorProto_DataType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

// Attributes
//
// A named attribute containing either singular float, integer, string, graph,
// and tensor values, or repeated float, integer, string, graph, and tensor values.
// An AttributeProto MUST contain the name field, and *only one* of the
// following content fields, effectively enforcing a C/C++ union equivalent.
type AttributeProto struct {
	// The name field MUST be present for this version of the IR.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
	// In this case, this AttributeProto does not contain data, and it's a reference of attribute
	// in parent scope.
	// NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
	RefAttrName *string `protobuf:"bytes,21,opt,name=ref_attr_name" json:"ref_attr_name,omitempty"`
	// A human-readable documentation for this attribute. Markdown is allowed.
	DocString *string `protobuf:"bytes,13,opt,name=doc_string" json:"doc_string,omitempty"`
	// The type field MUST be present for this version of the IR.
	// For 0.0.1 versions of the IR, this field was not defined, and
	// implementations needed to use has_field hueristics to determine
	// which value field was in use.  For IR_VERSION 0.0.2 or later, this
	// field MUST be set and match the f|i|s|t|... field in use.  This
	// change was made to accomodate proto3 implementations.
	Type *AttributeProto_AttributeType `protobuf:"varint,20,opt,name=type,enum=onnx.AttributeProto_AttributeType" json:"type,omitempty"`
	// Exactly ONE of the following fields must be present for this version of the IR
	F                *float32       `protobuf:"fixed32,2,opt,name=f" json:"f,omitempty"`
	I                *int64         `protobuf:"varint,3,opt,name=i" json:"i,omitempty"`
	S                []byte         `protobuf:"bytes,4,opt,name=s" json:"s,omitempty"`
	T                *TensorProto   `protobuf:"bytes,5,opt,name=t" json:"t,omitempty"`
	G                *GraphProto    `protobuf:"bytes,6,opt,name=g" json:"g,omitempty"`
	Floats           []float32      `protobuf:"fixed32,7,rep,name=floats" json:"floats,omitempty"`
	Ints             []int64        `protobuf:"varint,8,rep,name=ints" json:"ints,omitempty"`
	Strings          [][]byte       `protobuf:"bytes,9,rep,name=strings" json:"strings,omitempty"`
	Tensors          []*TensorProto `protobuf:"bytes,10,rep,name=tensors" json:"tensors,omitempty"`
	Graphs           []*GraphProto  `protobuf:"bytes,11,rep,name=graphs" json:"graphs,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *AttributeProto) Reset()                    { *m = AttributeProto{} }
func (m *AttributeProto) String() string            { return proto.CompactTextString(m) }
func (*AttributeProto) ProtoMessage()               {}
func (*AttributeProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AttributeProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *AttributeProto) GetRefAttrName() string {
	if m != nil && m.RefAttrName != nil {
		return *m.RefAttrName
	}
	return ""
}

func (m *AttributeProto) GetDocString() string {
	if m != nil && m.DocString != nil {
		return *m.DocString
	}
	return ""
}

func (m *AttributeProto) GetType() AttributeProto_AttributeType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return AttributeProto_UNDEFINED
}

func (m *AttributeProto) GetF() float32 {
	if m != nil && m.F != nil {
		return *m.F
	}
	return 0
}

func (m *AttributeProto) GetI() int64 {
	if m != nil && m.I != nil {
		return *m.I
	}
	return 0
}

func (m *AttributeProto) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *AttributeProto) GetT() *TensorProto {
	if m != nil {
		return m.T
	}
	return nil
}

func (m *AttributeProto) GetG() *GraphProto {
	if m != nil {
		return m.G
	}
	return nil
}

func (m *AttributeProto) GetFloats() []float32 {
	if m != nil {
		return m.Floats
	}
	return nil
}

func (m *AttributeProto) GetInts() []int64 {
	if m != nil {
		return m.Ints
	}
	return nil
}

func (m *AttributeProto) GetStrings() [][]byte {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *AttributeProto) GetTensors() []*TensorProto {
	if m != nil {
		return m.Tensors
	}
	return nil
}

func (m *AttributeProto) GetGraphs() []*GraphProto {
	if m != nil {
		return m.Graphs
	}
	return nil
}

// Defines information on value, including the name, the type, and
// the shape of the value.
type ValueInfoProto struct {
	// This field MUST be present in this version of the IR.
	Name *string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// This field MUST be present in this version of the IR.
	Type *TypeProto `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
	// A human-readable documentation for this value. Markdown is allowed.
	DocString        *string `protobuf:"bytes,3,opt,name=doc_string" json:"doc_string,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ValueInfoProto) Reset()                    { *m = ValueInfoProto{} }
func (m *ValueInfoProto) String() string            { return proto.CompactTextString(m) }
func (*ValueInfoProto) ProtoMessage()               {}
func (*ValueInfoProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ValueInfoProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ValueInfoProto) GetType() *TypeProto {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ValueInfoProto) GetDocString() string {
	if m != nil && m.DocString != nil {
		return *m.DocString
	}
	return ""
}

// Nodes
//
// Computation graphs are made up of a DAG of nodes, which represent what is
// commonly called a "layer" or "pipeline stage" in machine learning frameworks.
//
// For example, it can be a node of type "Conv" that takes in an image, a filter
// tensor and a bias tensor, and produces the convolved output.
type NodeProto struct {
	Input  []string `protobuf:"bytes,1,rep,name=input" json:"input,omitempty"`
	Output []string `protobuf:"bytes,2,rep,name=output" json:"output,omitempty"`
	// An optional identifier for this node in a graph.
	// This field MAY be absent in ths version of the IR.
	Name *string `protobuf:"bytes,3,opt,name=name" json:"name,omitempty"`
	// The symbolic identifier of the Operator to execute.
	OpType *string `protobuf:"bytes,4,opt,name=op_type" json:"op_type,omitempty"`
	// The domain of the OperatorSet that specifies the operator named by op_type.
	Domain *string `protobuf:"bytes,7,opt,name=domain" json:"domain,omitempty"`
	// Additional named attributes.
	Attribute []*AttributeProto `protobuf:"bytes,5,rep,name=attribute" json:"attribute,omitempty"`
	// A human-readable documentation for this node. Markdown is allowed.
	DocString        *string `protobuf:"bytes,6,opt,name=doc_string" json:"doc_string,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NodeProto) Reset()                    { *m = NodeProto{} }
func (m *NodeProto) String() string            { return proto.CompactTextString(m) }
func (*NodeProto) ProtoMessage()               {}
func (*NodeProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *NodeProto) GetInput() []string {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *NodeProto) GetOutput() []string {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *NodeProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *NodeProto) GetOpType() string {
	if m != nil && m.OpType != nil {
		return *m.OpType
	}
	return ""
}

func (m *NodeProto) GetDomain() string {
	if m != nil && m.Domain != nil {
		return *m.Domain
	}
	return ""
}

func (m *NodeProto) GetAttribute() []*AttributeProto {
	if m != nil {
		return m.Attribute
	}
	return nil
}

func (m *NodeProto) GetDocString() string {
	if m != nil && m.DocString != nil {
		return *m.DocString
	}
	return ""
}

// Models
//
// ModelProto is a top-level file/container format for bundling a ML model and
// associating its computation graph with metadata.
//
// The semantics of the model are described by the associated GraphProto.
type ModelProto struct {
	// The version of the IR this model targets. See Version enum above.
	// This field MUST be present.
	IrVersion *int64 `protobuf:"varint,1,opt,name=ir_version" json:"ir_version,omitempty"`
	// The OperatorSets this model relies on.
	// All ModelProtos MUST have at least one entry that
	// specifies which version of the ONNX OperatorSet is
	// being imported.
	//
	// All nodes in the ModelProto's graph will bind against the operator
	// with the same-domain/same-op_type operator with the HIGHEST version
	// in the referenced operator sets.
	OpsetImport []*OperatorSetIdProto `protobuf:"bytes,8,rep,name=opset_import" json:"opset_import,omitempty"`
	// The name of the framework or tool used to generate this model.
	// This field SHOULD be present to indicate which implementation/tool/framework
	// emitted the model.
	ProducerName *string `protobuf:"bytes,2,opt,name=producer_name" json:"producer_name,omitempty"`
	// The version of the framework or tool used to generate this model.
	// This field SHOULD be present to indicate which implementation/tool/framework
	// emitted the model.
	ProducerVersion *string `protobuf:"bytes,3,opt,name=producer_version" json:"producer_version,omitempty"`
	// Domain name of the model.
	// We use reverse domain names as name space indicators. For example:
	// `com.facebook.fair` or `com.microsoft.cognitiveservices`
	//
	// Together with `model_version` and GraphProto.name, this forms the unique identity of
	// the graph.
	Domain *string `protobuf:"bytes,4,opt,name=domain" json:"domain,omitempty"`
	// The version of the graph encoded. See Version enum below.
	ModelVersion *int64 `protobuf:"varint,5,opt,name=model_version" json:"model_version,omitempty"`
	// A human-readable documentation for this model. Markdown is allowed.
	DocString *string `protobuf:"bytes,6,opt,name=doc_string" json:"doc_string,omitempty"`
	// The parameterized graph that is evaluated to execute the model.
	Graph *GraphProto `protobuf:"bytes,7,opt,name=graph" json:"graph,omitempty"`
	// Named metadata values; keys should be distinct.
	MetadataProps    []*StringStringEntryProto `protobuf:"bytes,14,rep,name=metadata_props" json:"metadata_props,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *ModelProto) Reset()                    { *m = ModelProto{} }
func (m *ModelProto) String() string            { return proto.CompactTextString(m) }
func (*ModelProto) ProtoMessage()               {}
func (*ModelProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ModelProto) GetIrVersion() int64 {
	if m != nil && m.IrVersion != nil {
		return *m.IrVersion
	}
	return 0
}

func (m *ModelProto) GetOpsetImport() []*OperatorSetIdProto {
	if m != nil {
		return m.OpsetImport
	}
	return nil
}

func (m *ModelProto) GetProducerName() string {
	if m != nil && m.ProducerName != nil {
		return *m.ProducerName
	}
	return ""
}

func (m *ModelProto) GetProducerVersion() string {
	if m != nil && m.ProducerVersion != nil {
		return *m.ProducerVersion
	}
	return ""
}

func (m *ModelProto) GetDomain() string {
	if m != nil && m.Domain != nil {
		return *m.Domain
	}
	return ""
}

func (m *ModelProto) GetModelVersion() int64 {
	if m != nil && m.ModelVersion != nil {
		return *m.ModelVersion
	}
	return 0
}

func (m *ModelProto) GetDocString() string {
	if m != nil && m.DocString != nil {
		return *m.DocString
	}
	return ""
}

func (m *ModelProto) GetGraph() *GraphProto {
	if m != nil {
		return m.Graph
	}
	return nil
}

func (m *ModelProto) GetMetadataProps() []*StringStringEntryProto {
	if m != nil {
		return m.MetadataProps
	}
	return nil
}

// StringStringEntryProto follows the pattern for cross-proto-version maps.
// See https://developers.google.com/protocol-buffers/docs/proto3#maps
type StringStringEntryProto struct {
	Key              *string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *StringStringEntryProto) Reset()                    { *m = StringStringEntryProto{} }
func (m *StringStringEntryProto) String() string            { return proto.CompactTextString(m) }
func (*StringStringEntryProto) ProtoMessage()               {}
func (*StringStringEntryProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *StringStringEntryProto) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *StringStringEntryProto) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// Graphs
//
// A graph defines the computational logic of a model and is comprised of a parameterized
// list of nodes that form a directed acyclic graph based on their inputs and outputs.
// This is the equivalent of the "network" or "graph" in many deep learning
// frameworks.
type GraphProto struct {
	// The nodes in the graph, sorted topologically.
	Node []*NodeProto `protobuf:"bytes,1,rep,name=node" json:"node,omitempty"`
	// The name of the graph.
	Name *string `protobuf:"bytes,2,opt,name=name" json:"name,omitempty"`
	// A list of named tensor values, used to specify constant inputs of the graph.
	// Each TensorProto entry must have a distinct name (within the list) that
	// also appears in the input list.
	Initializer []*TensorProto `protobuf:"bytes,5,rep,name=initializer" json:"initializer,omitempty"`
	// A human-readable documentation for this graph. Markdown is allowed.
	DocString *string `protobuf:"bytes,10,opt,name=doc_string" json:"doc_string,omitempty"`
	// The inputs and outputs of the graph.
	Input  []*ValueInfoProto `protobuf:"bytes,11,rep,name=input" json:"input,omitempty"`
	Output []*ValueInfoProto `protobuf:"bytes,12,rep,name=output" json:"output,omitempty"`
	// Information for the values in the graph. The ValueInfoProto.name's
	// must be distinct. It is optional for a value to appear in value_info list.
	ValueInfo        []*ValueInfoProto `protobuf:"bytes,13,rep,name=value_info" json:"value_info,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *GraphProto) Reset()                    { *m = GraphProto{} }
func (m *GraphProto) String() string            { return proto.CompactTextString(m) }
func (*GraphProto) ProtoMessage()               {}
func (*GraphProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *GraphProto) GetNode() []*NodeProto {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *GraphProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *GraphProto) GetInitializer() []*TensorProto {
	if m != nil {
		return m.Initializer
	}
	return nil
}

func (m *GraphProto) GetDocString() string {
	if m != nil && m.DocString != nil {
		return *m.DocString
	}
	return ""
}

func (m *GraphProto) GetInput() []*ValueInfoProto {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *GraphProto) GetOutput() []*ValueInfoProto {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *GraphProto) GetValueInfo() []*ValueInfoProto {
	if m != nil {
		return m.ValueInfo
	}
	return nil
}

// Tensors
//
// A serialized tensor value.
type TensorProto struct {
	// The shape of the tensor.
	Dims []int64 `protobuf:"varint,1,rep,name=dims" json:"dims,omitempty"`
	// The data type of the tensor.
	DataType *TensorProto_DataType `protobuf:"varint,2,opt,name=data_type,enum=onnx.TensorProto_DataType" json:"data_type,omitempty"`
	Segment  *TensorProto_Segment  `protobuf:"bytes,3,opt,name=segment" json:"segment,omitempty"`
	// For float and complex64 values
	// Complex64 tensors are encoded as a single array of floats,
	// with the real components appearing in odd numbered positions,
	// and the corresponding imaginary component apparing in the
	// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
	// is encoded as [1.0, 2.0 ,3.0 ,4.0]
	// When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
	FloatData []float32 `protobuf:"fixed32,4,rep,packed,name=float_data" json:"float_data,omitempty"`
	// For int32, uint8, int8, uint16, int16, bool, and float16 values
	// float16 values must be bit-wise converted to an uint16_t prior
	// to writing to the buffer.
	// When this field is present, the data_type field MUST be
	// INT32, INT16, INT8, UINT16, INT8, BOOL, or FLOAT16
	Int32Data []int32 `protobuf:"varint,5,rep,packed,name=int32_data" json:"int32_data,omitempty"`
	// For strings.
	// Each element of string_data is a UTF-8 encoded Unicode
	// string. No trailing null, no leading BOM. The protobuf "string"
	// scalar type is not used to match ML community conventions.
	// When this field is present, the data_type field MUST be STRING
	StringData [][]byte `protobuf:"bytes,6,rep,name=string_data" json:"string_data,omitempty"`
	// For int64.
	// When this field is present, the data_type field MUST be INT64
	Int64Data []int64 `protobuf:"varint,7,rep,packed,name=int64_data" json:"int64_data,omitempty"`
	// Optionally, a name for the tensor.
	Name *string `protobuf:"bytes,8,opt,name=name" json:"name,omitempty"`
	// A human-readable documentation for this tensor. Markdown is allowed.
	DocString *string `protobuf:"bytes,12,opt,name=doc_string" json:"doc_string,omitempty"`
	// Serializations can either use one of the fields above, or use this
	// raw bytes field. The only exception is the string case, where one is
	// required to store the content in the repeated bytes string_data field.
	//
	// When this raw_data field is used to store tensor value, elements MUST
	// be stored in as fixed-width, little-endian order.
	// Floating-point data types MUST be stored in IEEE 754 format.
	// Complex64 elements must be written as two consecutive FLOAT values, real component first.
	// Complex128 elements must be written as two consecutive DOUBLE values, real component first.
	// Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
	//
	// Note: the advantage of specific field rather than the raw_data field is
	// that in some cases (e.g. int data), protobuf does a better packing via
	// variable length storage, and may lead to smaller binary footprint.
	// When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
	RawData []byte `protobuf:"bytes,9,opt,name=raw_data" json:"raw_data,omitempty"`
	// For double
	// Complex64 tensors are encoded as a single array of doubles,
	// with the real components appearing in odd numbered positions,
	// and the corresponding imaginary component apparing in the
	// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
	// is encoded as [1.0, 2.0 ,3.0 ,4.0]
	// When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
	DoubleData []float64 `protobuf:"fixed64,10,rep,packed,name=double_data" json:"double_data,omitempty"`
	// For uint64 and uint32 values
	// When this field is present, the data_type field MUST be
	// UINT32 or UINT64
	Uint64Data       []uint64 `protobuf:"varint,11,rep,packed,name=uint64_data" json:"uint64_data,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *TensorProto) Reset()                    { *m = TensorProto{} }
func (m *TensorProto) String() string            { return proto.CompactTextString(m) }
func (*TensorProto) ProtoMessage()               {}
func (*TensorProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *TensorProto) GetDims() []int64 {
	if m != nil {
		return m.Dims
	}
	return nil
}

func (m *TensorProto) GetDataType() TensorProto_DataType {
	if m != nil && m.DataType != nil {
		return *m.DataType
	}
	return TensorProto_UNDEFINED
}

func (m *TensorProto) GetSegment() *TensorProto_Segment {
	if m != nil {
		return m.Segment
	}
	return nil
}

func (m *TensorProto) GetFloatData() []float32 {
	if m != nil {
		return m.FloatData
	}
	return nil
}

func (m *TensorProto) GetInt32Data() []int32 {
	if m != nil {
		return m.Int32Data
	}
	return nil
}

func (m *TensorProto) GetStringData() [][]byte {
	if m != nil {
		return m.StringData
	}
	return nil
}

func (m *TensorProto) GetInt64Data() []int64 {
	if m != nil {
		return m.Int64Data
	}
	return nil
}

func (m *TensorProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *TensorProto) GetDocString() string {
	if m != nil && m.DocString != nil {
		return *m.DocString
	}
	return ""
}

func (m *TensorProto) GetRawData() []byte {
	if m != nil {
		return m.RawData
	}
	return nil
}

func (m *TensorProto) GetDoubleData() []float64 {
	if m != nil {
		return m.DoubleData
	}
	return nil
}

func (m *TensorProto) GetUint64Data() []uint64 {
	if m != nil {
		return m.Uint64Data
	}
	return nil
}

// For very large tensors, we may want to store them in chunks, in which
// case the following fields will specify the segment that is stored in
// the current TensorProto.
type TensorProto_Segment struct {
	Begin            *int64 `protobuf:"varint,1,opt,name=begin" json:"begin,omitempty"`
	End              *int64 `protobuf:"varint,2,opt,name=end" json:"end,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *TensorProto_Segment) Reset()                    { *m = TensorProto_Segment{} }
func (m *TensorProto_Segment) String() string            { return proto.CompactTextString(m) }
func (*TensorProto_Segment) ProtoMessage()               {}
func (*TensorProto_Segment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6, 0} }

func (m *TensorProto_Segment) GetBegin() int64 {
	if m != nil && m.Begin != nil {
		return *m.Begin
	}
	return 0
}

func (m *TensorProto_Segment) GetEnd() int64 {
	if m != nil && m.End != nil {
		return *m.End
	}
	return 0
}

// Defines a tensor shape. A dimension can be either an integer value
// or a symbolic variable. A symbolic variable represents an unknown
// dimension.
type TensorShapeProto struct {
	Dim              []*TensorShapeProto_Dimension `protobuf:"bytes,1,rep,name=dim" json:"dim,omitempty"`
	XXX_unrecognized []byte                        `json:"-"`
}

func (m *TensorShapeProto) Reset()                    { *m = TensorShapeProto{} }
func (m *TensorShapeProto) String() string            { return proto.CompactTextString(m) }
func (*TensorShapeProto) ProtoMessage()               {}
func (*TensorShapeProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *TensorShapeProto) GetDim() []*TensorShapeProto_Dimension {
	if m != nil {
		return m.Dim
	}
	return nil
}

type TensorShapeProto_Dimension struct {
	// Types that are valid to be assigned to Value:
	//	*TensorShapeProto_Dimension_DimValue
	//	*TensorShapeProto_Dimension_DimParam
	Value isTensorShapeProto_Dimension_Value `protobuf_oneof:"value"`
	// Standard denotation can optionally be used to denote tensor
	// dimensions with standard semantic descriptions to ensure
	// that operations are applied to the correct axis of a tensor.
	// Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
	// for pre-defined dimension denotations.
	Denotation       *string `protobuf:"bytes,3,opt,name=denotation" json:"denotation,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TensorShapeProto_Dimension) Reset()                    { *m = TensorShapeProto_Dimension{} }
func (m *TensorShapeProto_Dimension) String() string            { return proto.CompactTextString(m) }
func (*TensorShapeProto_Dimension) ProtoMessage()               {}
func (*TensorShapeProto_Dimension) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

type isTensorShapeProto_Dimension_Value interface {
	isTensorShapeProto_Dimension_Value()
}

type TensorShapeProto_Dimension_DimValue struct {
	DimValue int64 `protobuf:"varint,1,opt,name=dim_value,oneof"`
}
type TensorShapeProto_Dimension_DimParam struct {
	DimParam string `protobuf:"bytes,2,opt,name=dim_param,oneof"`
}

func (*TensorShapeProto_Dimension_DimValue) isTensorShapeProto_Dimension_Value() {}
func (*TensorShapeProto_Dimension_DimParam) isTensorShapeProto_Dimension_Value() {}

func (m *TensorShapeProto_Dimension) GetValue() isTensorShapeProto_Dimension_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TensorShapeProto_Dimension) GetDimValue() int64 {
	if x, ok := m.GetValue().(*TensorShapeProto_Dimension_DimValue); ok {
		return x.DimValue
	}
	return 0
}

func (m *TensorShapeProto_Dimension) GetDimParam() string {
	if x, ok := m.GetValue().(*TensorShapeProto_Dimension_DimParam); ok {
		return x.DimParam
	}
	return ""
}

func (m *TensorShapeProto_Dimension) GetDenotation() string {
	if m != nil && m.Denotation != nil {
		return *m.Denotation
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TensorShapeProto_Dimension) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TensorShapeProto_Dimension_OneofMarshaler, _TensorShapeProto_Dimension_OneofUnmarshaler, _TensorShapeProto_Dimension_OneofSizer, []interface{}{
		(*TensorShapeProto_Dimension_DimValue)(nil),
		(*TensorShapeProto_Dimension_DimParam)(nil),
	}
}

func _TensorShapeProto_Dimension_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TensorShapeProto_Dimension)
	// value
	switch x := m.Value.(type) {
	case *TensorShapeProto_Dimension_DimValue:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.DimValue))
	case *TensorShapeProto_Dimension_DimParam:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		b.EncodeStringBytes(x.DimParam)
	case nil:
	default:
		return fmt.Errorf("TensorShapeProto_Dimension.Value has unexpected type %T", x)
	}
	return nil
}

func _TensorShapeProto_Dimension_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TensorShapeProto_Dimension)
	switch tag {
	case 1: // value.dim_value
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &TensorShapeProto_Dimension_DimValue{int64(x)}
		return true, err
	case 2: // value.dim_param
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &TensorShapeProto_Dimension_DimParam{x}
		return true, err
	default:
		return false, nil
	}
}

func _TensorShapeProto_Dimension_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TensorShapeProto_Dimension)
	// value
	switch x := m.Value.(type) {
	case *TensorShapeProto_Dimension_DimValue:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.DimValue))
	case *TensorShapeProto_Dimension_DimParam:
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.DimParam)))
		n += len(x.DimParam)
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Types
//
// The standard ONNX data types.
type TypeProto struct {
	// Types that are valid to be assigned to Value:
	//	*TypeProto_TensorType
	Value isTypeProto_Value `protobuf_oneof:"value"`
	// An optional denotation can be used to denote the whole
	// type with a standard semantic description as to what is
	// stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
	// for pre-defined type denotations.
	Denotation       *string `protobuf:"bytes,6,opt,name=denotation" json:"denotation,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *TypeProto) Reset()                    { *m = TypeProto{} }
func (m *TypeProto) String() string            { return proto.CompactTextString(m) }
func (*TypeProto) ProtoMessage()               {}
func (*TypeProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isTypeProto_Value interface {
	isTypeProto_Value()
}

type TypeProto_TensorType struct {
	TensorType *TypeProto_Tensor `protobuf:"bytes,1,opt,name=tensor_type,oneof"`
}

func (*TypeProto_TensorType) isTypeProto_Value() {}

func (m *TypeProto) GetValue() isTypeProto_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TypeProto) GetTensorType() *TypeProto_Tensor {
	if x, ok := m.GetValue().(*TypeProto_TensorType); ok {
		return x.TensorType
	}
	return nil
}

func (m *TypeProto) GetDenotation() string {
	if m != nil && m.Denotation != nil {
		return *m.Denotation
	}
	return ""
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*TypeProto) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _TypeProto_OneofMarshaler, _TypeProto_OneofUnmarshaler, _TypeProto_OneofSizer, []interface{}{
		(*TypeProto_TensorType)(nil),
	}
}

func _TypeProto_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*TypeProto)
	// value
	switch x := m.Value.(type) {
	case *TypeProto_TensorType:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TensorType); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("TypeProto.Value has unexpected type %T", x)
	}
	return nil
}

func _TypeProto_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*TypeProto)
	switch tag {
	case 1: // value.tensor_type
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TypeProto_Tensor)
		err := b.DecodeMessage(msg)
		m.Value = &TypeProto_TensorType{msg}
		return true, err
	default:
		return false, nil
	}
}

func _TypeProto_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*TypeProto)
	// value
	switch x := m.Value.(type) {
	case *TypeProto_TensorType:
		s := proto.Size(x.TensorType)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type TypeProto_Tensor struct {
	// This field MUST NOT have the value of UNDEFINED
	// This field MUST be present for this version of the IR.
	ElemType         *TensorProto_DataType `protobuf:"varint,1,opt,name=elem_type,enum=onnx.TensorProto_DataType" json:"elem_type,omitempty"`
	Shape            *TensorShapeProto     `protobuf:"bytes,2,opt,name=shape" json:"shape,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *TypeProto_Tensor) Reset()                    { *m = TypeProto_Tensor{} }
func (m *TypeProto_Tensor) String() string            { return proto.CompactTextString(m) }
func (*TypeProto_Tensor) ProtoMessage()               {}
func (*TypeProto_Tensor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

func (m *TypeProto_Tensor) GetElemType() TensorProto_DataType {
	if m != nil && m.ElemType != nil {
		return *m.ElemType
	}
	return TensorProto_UNDEFINED
}

func (m *TypeProto_Tensor) GetShape() *TensorShapeProto {
	if m != nil {
		return m.Shape
	}
	return nil
}

// Operator Sets
//
// OperatorSets are uniquely identified by a (domain, opset_version) pair.
type OperatorSetIdProto struct {
	// The domain of the operator set being identified.
	// The empty string ("") or absence of this field implies the operator
	// set that is defined as part of the ONNX specification.
	// This field MUST be present in this version of the IR when referring to any other operator set.
	Domain *string `protobuf:"bytes,1,opt,name=domain" json:"domain,omitempty"`
	// The version of the operator set being identified.
	// This field MUST be present in this version of the IR.
	Version          *int64 `protobuf:"varint,2,opt,name=version" json:"version,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *OperatorSetIdProto) Reset()                    { *m = OperatorSetIdProto{} }
func (m *OperatorSetIdProto) String() string            { return proto.CompactTextString(m) }
func (*OperatorSetIdProto) ProtoMessage()               {}
func (*OperatorSetIdProto) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *OperatorSetIdProto) GetDomain() string {
	if m != nil && m.Domain != nil {
		return *m.Domain
	}
	return ""
}

func (m *OperatorSetIdProto) GetVersion() int64 {
	if m != nil && m.Version != nil {
		return *m.Version
	}
	return 0
}

func init() {
	proto.RegisterType((*AttributeProto)(nil), "onnx.AttributeProto")
	proto.RegisterType((*ValueInfoProto)(nil), "onnx.ValueInfoProto")
	proto.RegisterType((*NodeProto)(nil), "onnx.NodeProto")
	proto.RegisterType((*ModelProto)(nil), "onnx.ModelProto")
	proto.RegisterType((*StringStringEntryProto)(nil), "onnx.StringStringEntryProto")
	proto.RegisterType((*GraphProto)(nil), "onnx.GraphProto")
	proto.RegisterType((*TensorProto)(nil), "onnx.TensorProto")
	proto.RegisterType((*TensorProto_Segment)(nil), "onnx.TensorProto.Segment")
	proto.RegisterType((*TensorShapeProto)(nil), "onnx.TensorShapeProto")
	proto.RegisterType((*TensorShapeProto_Dimension)(nil), "onnx.TensorShapeProto.Dimension")
	proto.RegisterType((*TypeProto)(nil), "onnx.TypeProto")
	proto.RegisterType((*TypeProto_Tensor)(nil), "onnx.TypeProto.Tensor")
	proto.RegisterType((*OperatorSetIdProto)(nil), "onnx.OperatorSetIdProto")
	proto.RegisterEnum("onnx.Version", Version_name, Version_value)
	proto.RegisterEnum("onnx.AttributeProto_AttributeType", AttributeProto_AttributeType_name, AttributeProto_AttributeType_value)
	proto.RegisterEnum("onnx.TensorProto_DataType", TensorProto_DataType_name, TensorProto_DataType_value)
}

func init() { proto.RegisterFile("onnx.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1129 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x55, 0xdb, 0x6e, 0xdb, 0x46,
	0x13, 0x36, 0x45, 0x52, 0x14, 0x87, 0x92, 0xb2, 0xff, 0x26, 0x76, 0x18, 0xff, 0x09, 0x4a, 0xa8,
	0x4d, 0x2b, 0x04, 0x88, 0x61, 0xc9, 0xaa, 0xea, 0x5b, 0xbb, 0x56, 0x6c, 0x01, 0x8e, 0xe4, 0x8a,
	0xb2, 0xd1, 0xab, 0x12, 0xb4, 0xb9, 0x76, 0x88, 0x8a, 0x07, 0x90, 0xab, 0xb4, 0xee, 0x5b, 0x14,
	0x45, 0xfb, 0x1a, 0xbd, 0xec, 0x4b, 0xf4, 0x21, 0x7a, 0xdd, 0xa7, 0x28, 0x76, 0x96, 0x94, 0x64,
	0x5b, 0xce, 0x0d, 0xb1, 0x3b, 0x33, 0x3b, 0xc7, 0x6f, 0x3e, 0x02, 0x24, 0x71, 0xfc, 0xf3, 0x4e,
	0x9a, 0x25, 0x3c, 0xa1, 0x9a, 0x38, 0xb7, 0xfe, 0x51, 0xa1, 0x79, 0xc0, 0x79, 0x16, 0x5e, 0xce,
	0x39, 0x3b, 0x43, 0x45, 0x1d, 0xb4, 0xd8, 0x8f, 0x98, 0xad, 0x38, 0x4a, 0xdb, 0xa4, 0x9b, 0xd0,
	0xc8, 0xd8, 0xb5, 0xe7, 0x73, 0x9e, 0x79, 0x28, 0xde, 0x44, 0x31, 0x05, 0x08, 0x92, 0x2b, 0x2f,
	0xe7, 0x59, 0x18, 0xdf, 0xd8, 0x0d, 0x94, 0xed, 0x82, 0xc6, 0x6f, 0x53, 0x66, 0x3f, 0x73, 0x94,
	0x76, 0xb3, 0xdb, 0xda, 0xc1, 0x60, 0x77, 0x9d, 0x2f, 0xaf, 0xd3, 0xdb, 0x94, 0x51, 0x13, 0x94,
	0x6b, 0xbb, 0xe2, 0x28, 0xed, 0x8a, 0x38, 0x86, 0xb6, 0xea, 0x28, 0x6d, 0x55, 0x1c, 0x73, 0x5b,
	0x73, 0x94, 0x76, 0x9d, 0xbe, 0x04, 0x85, 0xdb, 0xba, 0xa3, 0xb4, 0xad, 0xee, 0xff, 0xa4, 0xbf,
	0x29, 0x8b, 0xf3, 0x24, 0x93, 0x99, 0xfe, 0x1f, 0x94, 0x1b, 0xbb, 0x8a, 0x5a, 0x22, 0xb5, 0xc7,
	0x99, 0x9f, 0x7e, 0x90, 0xca, 0x26, 0x54, 0xaf, 0x67, 0x89, 0xcf, 0x73, 0xdb, 0x70, 0xd4, 0x76,
	0x45, 0x94, 0x15, 0xc6, 0x3c, 0xb7, 0x6b, 0x8e, 0xda, 0x56, 0xe9, 0x13, 0x30, 0x64, 0xee, 0xb9,
	0x6d, 0x3a, 0x6a, 0xbb, 0x4e, 0x5b, 0x60, 0x70, 0x74, 0x9d, 0xdb, 0xe0, 0xa8, 0xeb, 0xe3, 0x39,
	0x50, 0xbd, 0x11, 0x01, 0x72, 0xdb, 0x42, 0x93, 0x07, 0x41, 0x5b, 0xbf, 0x2a, 0xd0, 0xb8, 0x5b,
	0x62, 0x03, 0xcc, 0xf3, 0xd1, 0xd1, 0xe0, 0xdd, 0x70, 0x34, 0x38, 0x22, 0x1b, 0xd4, 0x04, 0xfd,
	0xdd, 0xe9, 0xf8, 0x60, 0x4a, 0x14, 0x6a, 0x80, 0x3a, 0x1c, 0x4d, 0x49, 0x85, 0x02, 0x54, 0xdd,
	0xe9, 0x64, 0x38, 0x3a, 0x26, 0xaa, 0x38, 0x4f, 0x07, 0x23, 0x77, 0x3c, 0x21, 0x9a, 0xb0, 0x3d,
	0x9e, 0x1c, 0x9c, 0x9d, 0x10, 0x5d, 0x88, 0xf1, 0x99, 0x4b, 0xaa, 0xb4, 0x06, 0xda, 0x70, 0x34,
	0x75, 0x89, 0x41, 0x2d, 0x30, 0xe4, 0x43, 0x97, 0xd4, 0xc4, 0x45, 0xbe, 0x74, 0x89, 0x29, 0xec,
	0xf1, 0xa9, 0x4b, 0xa0, 0xf5, 0x1d, 0x34, 0x2f, 0xfc, 0xd9, 0x9c, 0x0d, 0xe3, 0xeb, 0x64, 0xdd,
	0x84, 0x5f, 0x15, 0x63, 0xab, 0x60, 0x23, 0x9f, 0x14, 0x65, 0xdf, 0xa6, 0x05, 0x1c, 0xee, 0x4e,
	0x5a, 0x4c, 0xc8, 0x6c, 0xfd, 0xa1, 0x80, 0x39, 0x4a, 0x82, 0xc2, 0xa2, 0x01, 0x7a, 0x18, 0xa7,
	0x73, 0x6e, 0x2b, 0x8e, 0xda, 0x36, 0x45, 0xe3, 0x93, 0x39, 0x17, 0xf7, 0x0a, 0xde, 0xcb, 0x68,
	0xf8, 0x54, 0x34, 0x3e, 0x49, 0x3d, 0x0c, 0xa8, 0xa1, 0xa0, 0x09, 0xd5, 0x20, 0x89, 0xfc, 0x30,
	0xb6, 0x0d, 0xbc, 0x7f, 0x05, 0xa6, 0x5f, 0x76, 0xd0, 0xd6, 0xb1, 0xcf, 0xcf, 0xd6, 0x41, 0xe9,
	0x5e, 0x62, 0x55, 0x4c, 0xec, 0xb7, 0x0a, 0xc0, 0xfb, 0x24, 0x60, 0xb3, 0x85, 0x49, 0x98, 0x79,
	0x1f, 0x59, 0x96, 0x87, 0x49, 0x8c, 0xe5, 0xaa, 0x74, 0x07, 0xea, 0x49, 0x9a, 0x33, 0xee, 0x85,
	0x51, 0x9a, 0x64, 0x1c, 0xf1, 0x60, 0x75, 0x6d, 0x19, 0x62, 0x9c, 0xb2, 0xcc, 0xe7, 0x49, 0xe6,
	0x32, 0x3e, 0x0c, 0xa4, 0x8f, 0x4d, 0x68, 0xa4, 0x59, 0x12, 0xcc, 0xaf, 0x58, 0xb1, 0x00, 0x15,
	0x4c, 0xd3, 0x06, 0xb2, 0x10, 0x97, 0x01, 0xd4, 0x7b, 0x05, 0x69, 0xe5, 0x06, 0x45, 0x22, 0xa5,
	0x85, 0x99, 0x8e, 0x79, 0xac, 0x49, 0x9f, 0x7e, 0x06, 0x3a, 0x02, 0x0c, 0x5b, 0xb1, 0x0e, 0xd4,
	0x3d, 0x68, 0x46, 0x8c, 0xfb, 0x81, 0xcf, 0x7d, 0x2f, 0xcd, 0x92, 0x34, 0xb7, 0x9b, 0x98, 0xfe,
	0x4b, 0x69, 0xe9, 0xa2, 0x33, 0xf9, 0x1d, 0xc4, 0x3c, 0xbb, 0x95, 0xa8, 0xec, 0xc1, 0xd6, 0x7a,
	0x0d, 0xb5, 0x40, 0xfd, 0x91, 0xdd, 0x16, 0x40, 0x68, 0x80, 0xfe, 0x51, 0x00, 0x45, 0x56, 0xd8,
	0xfa, 0x57, 0x01, 0x58, 0x09, 0xfd, 0x0a, 0xb4, 0x38, 0x09, 0x18, 0x0e, 0x79, 0x01, 0x93, 0x25,
	0x08, 0xca, 0x29, 0xcb, 0xee, 0x7c, 0x09, 0x56, 0x18, 0x87, 0x3c, 0xf4, 0x67, 0xe1, 0x2f, 0x2c,
	0x2b, 0xc6, 0xb8, 0x66, 0xa3, 0xee, 0x36, 0x01, 0xf0, 0xed, 0xe7, 0x25, 0x9c, 0xac, 0xd5, 0xe1,
	0xdf, 0x83, 0xf0, 0x17, 0x0b, 0x90, 0xd5, 0x3f, 0x61, 0xd5, 0x06, 0xc0, 0x8a, 0xbc, 0x30, 0xbe,
	0x4e, 0xec, 0xc6, 0xe3, 0x96, 0xad, 0x3f, 0x35, 0xb0, 0x56, 0x13, 0xab, 0x83, 0x16, 0x84, 0x51,
	0x8e, 0xd5, 0xaa, 0xf4, 0x2d, 0x98, 0xd8, 0xf2, 0xc5, 0x9e, 0x34, 0xbb, 0xdb, 0x0f, 0x8a, 0xd9,
	0x39, 0xf2, 0xb9, 0x8f, 0x3b, 0xff, 0x06, 0x8c, 0x9c, 0xdd, 0x44, 0x2c, 0xe6, 0x08, 0x09, 0xab,
	0xfb, 0xe2, 0xa1, 0xb1, 0x2b, 0x0d, 0xe8, 0x16, 0x00, 0xd2, 0x94, 0x27, 0x02, 0xd8, 0x9a, 0xa0,
	0xaa, 0xc3, 0x0a, 0x51, 0x84, 0x3c, 0x8c, 0xf9, 0x5e, 0x57, 0xca, 0x45, 0x03, 0x75, 0x94, 0x3f,
	0x05, 0x4b, 0x76, 0x4b, 0x2a, 0xaa, 0x48, 0x5e, 0xd2, 0xb8, 0xdf, 0x93, 0x32, 0xc1, 0x77, 0x2a,
	0x1a, 0x97, 0x43, 0xa9, 0xad, 0xe1, 0xec, 0x3a, 0xca, 0x08, 0xd4, 0x32, 0xff, 0x27, 0xf9, 0xce,
	0x44, 0xca, 0x7d, 0x0e, 0x56, 0x90, 0xcc, 0x2f, 0x67, 0x4c, 0x0a, 0x05, 0x19, 0x2a, 0xe8, 0xec,
	0x39, 0x58, 0xf3, 0x95, 0x28, 0x62, 0x3a, 0x9a, 0x50, 0x6c, 0xbf, 0x06, 0xa3, 0xac, 0xa6, 0x01,
	0xfa, 0x25, 0xbb, 0x09, 0xcb, 0x5d, 0xb3, 0x40, 0x65, 0x71, 0x80, 0x1d, 0x53, 0x5b, 0x7f, 0x2b,
	0x50, 0x5b, 0xb4, 0xe8, 0x71, 0x5a, 0x34, 0x41, 0x3f, 0x1f, 0x8e, 0xa6, 0xfb, 0xa4, 0x52, 0x30,
	0xdd, 0xbe, 0xa4, 0x45, 0x21, 0xec, 0xf4, 0x25, 0x2d, 0xca, 0xa3, 0x5e, 0x1c, 0xf7, 0xba, 0xa4,
	0x5a, 0x1c, 0xfb, 0x3d, 0x62, 0xac, 0xf0, 0x69, 0x4d, 0xb8, 0x38, 0x1c, 0x8f, 0x4f, 0x89, 0x29,
	0xf8, 0x11, 0x43, 0x74, 0xfa, 0x04, 0x84, 0xc9, 0xd1, 0xf8, 0xfc, 0xf0, 0x74, 0x40, 0xac, 0xd2,
	0xf7, 0x5e, 0x97, 0xd4, 0xcb, 0x73, 0xbf, 0x47, 0x1a, 0x22, 0xc5, 0x6f, 0xc7, 0xef, 0xcf, 0x4e,
	0x07, 0xdf, 0xf7, 0x7b, 0xa4, 0x49, 0x9b, 0x00, 0xc5, 0xb5, 0xd3, 0xdd, 0x27, 0x4f, 0x5a, 0xbf,
	0x2b, 0x40, 0xe4, 0x40, 0xdd, 0x0f, 0x7e, 0x49, 0x96, 0x6f, 0x41, 0x0d, 0xc2, 0xa8, 0xd8, 0x11,
	0x67, 0x75, 0xea, 0x4b, 0xa3, 0x9d, 0xa3, 0x30, 0x62, 0xb1, 0x60, 0x82, 0xed, 0x09, 0x98, 0x8b,
	0x0b, 0x7d, 0x0a, 0x66, 0x10, 0x46, 0x9e, 0x5c, 0x41, 0xec, 0xdf, 0xc9, 0x46, 0x29, 0x4c, 0xfd,
	0xcc, 0x8f, 0xe4, 0x6e, 0x9d, 0x6c, 0xe0, 0x20, 0x59, 0x9c, 0x70, 0x9f, 0x2f, 0x58, 0xe7, 0xd0,
	0x28, 0x96, 0xb7, 0xf5, 0x97, 0x02, 0xe6, 0x92, 0xbd, 0xdf, 0x82, 0x25, 0x7f, 0x6b, 0x12, 0xbb,
	0x0a, 0xc2, 0x71, 0xeb, 0x1e, 0xc7, 0x17, 0x29, 0x3e, 0xf0, 0x8c, 0xa4, 0xb4, 0xfd, 0x03, 0x54,
	0xa5, 0x5e, 0xac, 0x01, 0x9b, 0xb1, 0x68, 0xe9, 0xea, 0xd3, 0x6b, 0xf0, 0x1a, 0xf4, 0x5c, 0x54,
	0x5d, 0xfc, 0x59, 0xb6, 0xd6, 0xb7, 0x63, 0x99, 0xf9, 0xd7, 0x40, 0xd7, 0xf0, 0xef, 0x92, 0x4e,
	0x95, 0xf2, 0x07, 0x52, 0x12, 0x29, 0xe2, 0xea, 0xcd, 0x15, 0x18, 0x17, 0x52, 0x40, 0x29, 0x34,
	0x3d, 0x77, 0x7a, 0x30, 0x99, 0x7a, 0x17, 0x83, 0x89, 0x3b, 0x1c, 0x8f, 0xc8, 0x06, 0x7d, 0x01,
	0x9b, 0xc3, 0x49, 0x79, 0xf7, 0xba, 0xbb, 0x9d, 0x6f, 0xbc, 0xce, 0xae, 0xd7, 0xd9, 0x25, 0xca,
	0x23, 0xaa, 0xbd, 0x5d, 0x52, 0x11, 0xd3, 0x5e, 0xaa, 0x88, 0xfa, 0x5f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x69, 0xf5, 0xbb, 0x70, 0x3a, 0x09, 0x00, 0x00,
}
